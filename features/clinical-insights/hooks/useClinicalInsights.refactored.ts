/**
 * Refactored Clinical Insights Hook
 * Consolidates all insight generation logic into a single, testable hook
 * Following Single Responsibility and DRY principles
 */

import { useState, useCallback, useEffect, useRef } from 'react'
import { useUnifiedAi } from '@/src/application/hooks/ai/use-unified-ai.hook'
import { useClinicalContext } from '@/src/application/hooks/use-clinical-context.hook'
import { useClinicalInsightsConfig } from '@/src/application/providers/clinical-insights-config.provider'
import { useClinicalData } from '@/src/application/providers/clinical-data.provider'
import { hasChatProxy } from '@/src/shared/config/env.config'
import { useApiKey } from '@/src/application/providers/api-key.provider'

interface PanelState {
  response: string
  isLoading: boolean
  error: string | null
  isEdited: boolean
  metadata: {
    modelId: string
    provider: string
  } | null
}

interface UseClinicalInsightsReturn {
  panels: Array<{
    id: string
    title: string
    subtitle?: string
    prompt: string
    autoGenerate?: boolean
  }>
  panelStates: Record<string, PanelState>
  generate: (panelId: string, options?: { force?: boolean }) => Promise<void>
  stop: (panelId: string) => void
  updateResponse: (panelId: string, text: string) => void
  updatePrompt: (panelId: string, prompt: string) => void
  canGenerate: boolean
  hasData: boolean
}

/**
 * Unified Clinical Insights Hook
 * Manages all insight generation state and logic
 */
export function useClinicalInsights(): UseClinicalInsightsReturn {
  const { panels, updatePanel } = useClinicalInsightsConfig()
  const { getFullClinicalContext } = useClinicalContext()
  const { isLoading: clinicalDataLoading } = useClinicalData()
  const { apiKey: openAiKey, geminiKey } = useApiKey()
  const ai = useUnifiedAi()

  const [context, setContext] = useState('')
  const [panelStates, setPanelStates] = useState<Record<string, PanelState>>({})
  const currentPanelRef = useRef<string | null>(null)
  const hasAutoGeneratedRef = useRef<Set<string>>(new Set())

  // Check if AI generation is available
  const canUseProxy = hasChatProxy
  const canGenerate = Boolean(openAiKey || geminiKey) || canUseProxy
  const hasData = !clinicalDataLoading && context.trim().length > 0

  // Update context when clinical data changes
  useEffect(() => {
    const latestContext = getFullClinicalContext()
    setContext(latestContext)
  }, [getFullClinicalContext])

  // Initialize panel states
  useEffect(() => {
    const initialStates: Record<string, PanelState> = {}
    panels.forEach((panel) => {
      if (!panelStates[panel.id]) {
        initialStates[panel.id] = {
          response: '',
          isLoading: false,
          error: null,
          isEdited: false,
          metadata: null,
        }
      }
    })
    if (Object.keys(initialStates).length > 0) {
      setPanelStates((prev) => ({ ...prev, ...initialStates }))
    }
  }, [panels])

  /**
   * Generate insight for a specific panel
   */
  const generate = useCallback(
    async (panelId: string, options?: { force?: boolean }) => {
      const panel = panels.find((p) => p.id === panelId)
      if (!panel) return

      // Skip if already has response and not forced
      if (!options?.force && panelStates[panelId]?.response && !panelStates[panelId]?.isEdited) {
        return
      }

      if (!canGenerate || !hasData) {
        return
      }

      currentPanelRef.current = panelId

      // Set loading state
      setPanelStates((prev) => ({
        ...prev,
        [panelId]: {
          ...prev[panelId],
          isLoading: true,
          error: null,
        },
      }))

      try {
        // Build messages
        const messages = [
          { role: 'system' as const, content: 'You are a helpful clinical assistant.' },
          {
            role: 'user' as const,
            content: `${panel.prompt}\n\nClinical Context:\n${context}`,
          },
        ]

        // Stream the response
        await ai.stream(messages, {
          onChunk: (chunk) => {
            setPanelStates((prev) => ({
              ...prev,
              [panelId]: {
                ...prev[panelId],
                response: chunk,
                isEdited: false,
              },
            }))
          },
          onComplete: (fullText) => {
            setPanelStates((prev) => ({
              ...prev,
              [panelId]: {
                ...prev[panelId],
                response: fullText,
                isLoading: false,
                isEdited: false,
                metadata: {
                  modelId: 'gpt-4', // TODO: Get from actual model
                  provider: 'openai',
                },
              },
            }))
          },
        })
      } catch (error) {
        setPanelStates((prev) => ({
          ...prev,
          [panelId]: {
            ...prev[panelId],
            isLoading: false,
            error: error instanceof Error ? error.message : 'Generation failed',
          },
        }))
      } finally {
        currentPanelRef.current = null
      }
    },
    [panels, panelStates, canGenerate, hasData, context, ai]
  )

  /**
   * Stop generation for a specific panel
   */
  const stop = useCallback(
    (panelId: string) => {
      if (currentPanelRef.current === panelId) {
        ai.stop()
        setPanelStates((prev) => ({
          ...prev,
          [panelId]: {
            ...prev[panelId],
            isLoading: false,
          },
        }))
      }
    },
    [ai]
  )

  /**
   * Update response text (manual edit)
   */
  const updateResponse = useCallback((panelId: string, text: string) => {
    setPanelStates((prev) => ({
      ...prev,
      [panelId]: {
        ...prev[panelId],
        response: text,
        isEdited: true,
      },
    }))
  }, [])

  /**
   * Update prompt
   */
  const updatePrompt = useCallback(
    (panelId: string, prompt: string) => {
      updatePanel(panelId, { prompt })
    },
    [updatePanel]
  )

  /**
   * Auto-generate insights when data is ready
   */
  useEffect(() => {
    if (!canGenerate || !hasData) return

    panels.forEach((panel) => {
      if (panel.autoGenerate && !hasAutoGeneratedRef.current.has(panel.id)) {
        hasAutoGeneratedRef.current.add(panel.id)
        generate(panel.id)
      }
    })
  }, [panels, canGenerate, hasData, generate])

  return {
    panels,
    panelStates,
    generate,
    stop,
    updateResponse,
    updatePrompt,
    canGenerate,
    hasData,
  }
}
